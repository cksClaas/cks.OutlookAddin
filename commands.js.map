{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/RoamingSettings.ts","webpack:///./node_modules/process/browser.js","webpack:///./src/MultiDelegate.ts","webpack:///./src/Categories.ts","webpack:///./src/CustomProperties.ts","webpack:///./node_modules/es6-promise/dist/es6-promise.js","webpack:///./src/LocalStorage.ts","webpack:///./src/AuthenticationState.ts","webpack:///./src/Logger.ts","webpack:///./node_modules/using-statement/dist/index.js","webpack:///./node_modules/using-statement/dist/using.js","webpack:///./node_modules/jwt-decode/build/jwt-decode.esm.js","webpack:///./src/CksApiClient.ts","webpack:///./src/NotificationMessages.ts","webpack:///./src/Item.ts","webpack:///./src/Mailbox.ts","webpack:///./src/commands/commands.ts","webpack:///./src/Dialog.ts","webpack:///(webpack)/buildin/global.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","console","info","result","Office","context","roamingSettings","JSON","parse","addInSettings","settings","asString","stringify","set","Promise","resolve","reject","saveAsync","status","AsyncResultStatus","Failed","error","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","_callbacks","add","callback","remove","index","indexOf","splice","delegate","MultiDelegate","invoke","forEach","isCategoriesSupported","isSupported","requirements","isSetSupported","isArchivedCategory","displayName","color","MailboxEnums","CategoryColor","Preset7","masterCategoriesToAdd","mailbox","masterCategories","getAsync","existingCategories","missingCategories","filter","category","every","existing","addAsync","item","categories","categoryName","archiveDetails","properties","_properties","load","loadCustomPropertiesAsync","customProperties","update","factory","isFunction","x","isArray","toString","vertxNext","customSchedulerFn","asap","arg","flush","scheduleFlush","browserWindow","window","undefined","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","self","isWorker","Uint8ClampedArray","importScripts","MessageChannel","useSetTimeout","globalSetTimeout","channel","iterations","observer","node","then","onFulfillment","onRejection","parent","child","constructor","PROMISE_ID","makePromise","_state","invokeCallback","_result","subscribe","resolve$1","promise","document","createTextNode","observe","characterData","data","port1","onmessage","port2","postMessage","vertx","Function","require","runOnLoop","runOnContext","attemptVertx","Math","random","substring","handleMaybeThenable","maybeThenable","then$$1","thenable","fulfill","reason","handleOwnThenable","sealed","fulfillmentHandler","rejectionHandler","tryThen","_label","handleForeignThenable","TypeError","type","publishRejection","_onerror","publish","_subscribers","subscribers","settled","detail","hasCallback","succeeded","id","Enumerator","Constructor","input","_instanceConstructor","_remaining","_enumerate","_eachEntry","entry","resolve$$1","_then","didError","_settledAt","Promise$1","_willSettleAt","state","enumerator","resolver","needsResolver","initializePromise","needsNew","catch","finally","all","entries","race","_","_setScheduler","scheduleFn","_setAsap","asapFn","_asap","polyfill","local","global","P","promiseToString","cast","keys","dialogOptions","cksTokens","tokens","localStorage","setItem","json","getItem","authenticationStateChanged","_notifyStateChanged","_tokens","getTokens","AuthenticationState","Roaming","getSettings","accessToken","refreshToken","access_token","refresh_token","Storage","signIn","user","password","api","fetchTokens","setTokens","using","Logger","createScope","body","URLSearchParams","append","url","URL","log","fetch","method","response","logError","signOut","old","refreshing","setSettings","refreshTokens","headers","ok","isExpired","decoded","currentTime","Date","getTime","tokenExpires","exp","isAuthenticated","isTokensValid","message","optionalParams","ScopedLogger","group","dispose","groupEnd","__export","resource","func","shouldDispose","isPromise","capturedResult","obj","next","originalNext","from","iterationResult","done","err","disposeResult","finalPromise","funcNames","funcName","atob","String","replace","a","charAt","fromCharCode","decodeURIComponent","charCodeAt","toUpperCase","header","split","authState","invokeRequestFailed","onRequestFailed","getCategories","database","getObjectTypes","getActiveSessions","getBusinessPartnersByMail","address","getBusinessPartners","getDocumentsOfBusinessPartner","code","updateExchangeToken","exchangeToken","createEmailArchive","request","getDocumentOfArchive","archiveId","relativeUrl","getRequirements","Authorization","ApiClient","JSONmessage","notificationMessages","Succeeded","replaceAsync","removeAsync","actionKey","Notifications","getItemId","hostName","diagnostics","itemId","convertToRestId","RestVersion","v2_0","getEmailIdentifier","tokenPromise","getCallBackToken","restUrl","token","sender","emailAddress","toLowerCase","userProfile","isSent","getCallbackTokenAsync","Mailbox","resolveOnReady","onReady","initializeAction","signInMessage","ItemNotificationMessageType","ErrorMessage","isInitialized","tryCreateArchive","archivedInDatabases","createSuccessMessage","errorMessage","archive","propertiesPromise","categoriesPromise","tryInitializeCategories","tryAddCategoriesToItem","successMessage","InformationalMessage","icon","persistent","showChooseOptionDialog","options","messageToChild","query","map","location","origin","displayDialog","height","width","displayInIframe","dialog","databaseSelectedPromise","addEventHandler","EventType","DialogEventReceived","DialogMessageReceived","argument","close","removeItem","runArchiveAction","event","getValidSessions","getArchiveIdentifier","generateSuccessMessage","completed","sessions","session","noSessionMessage","valid","companyName","selectedCompany","find","ProgressIndicator","email","exceptionMessage","g","archiveInInbox","chosenContext","key1","archiveBehindBusinessPartner","getAddressesPromisses","partners","results","notFoundMessage","businessPartnerCode","startAddress","ui","displayDialogAsync"],"mappings":"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","file":"commands.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 753);\n","\r\nconst settingsName = \"Settings\";\r\nexport interface ISettings {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n  api: string;\r\n}\r\nexport function getSettings(): ISettings {\r\n  console.info(\"Getting roaming settings\");\r\n  const settings = Office.context.roamingSettings;\r\n  let result = settings.get(settingsName);\r\n  console.info(\"Got roaming settings\", { result });\r\n  if (!result) return null;\r\n\r\n  result = JSON.parse(result) as ISettings;\r\n  console.info(\"Loaded roaming settings\", result);\r\n\r\n  return result as ISettings;\r\n}\r\n\r\n// make a promise to make the save settings saveAsync awaitable without callback\r\nfunction saveAsync(): Promise<void> {\r\n  return new Promise<void>((resolve, reject) => {\r\n    const settings = Office.context.roamingSettings;\r\n    console.info(\"Saving roaming settings\");\r\n    settings.saveAsync((result) => {\r\n      if (result.status === Office.AsyncResultStatus.Failed) {\r\n        console.error(\"Failed setting roaming settings\");\r\n        reject(result.error);\r\n        return;\r\n      }\r\n\r\n      console.info(\"Saved roaming settings\");\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\nexport async function setSettings(addInSettings: ISettings): Promise<void> {\r\n  console.info(\"Setting roaming settings: \", addInSettings);\r\n  const settings = Office.context.roamingSettings;\r\n\r\n  const asString = JSON.stringify(addInSettings);\r\n  console.info(\"Roaming settings as string\", { asString });\r\n  settings.set(settingsName, asString);\r\n\r\n  await saveAsync();\r\n}\r\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\r\nexport class MultiDelegate<T> {\r\n    private _callbacks = new Array<(value: T) => void>();\r\n\r\n    // use this to subscribe to the invokation list\r\n    public add(callback: (value: T) => void) {\r\n        this._callbacks.push(callback);\r\n    }\r\n\r\n    public remove(callback: (value: T) => void) {\r\n        const index = this._callbacks.indexOf(callback);\r\n        if (index > -1)\r\n            this._callbacks.splice(index, 1);\r\n    }\r\n\r\n    public static create<T>(): { delegate: MultiDelegate<T>; invoke: (value: T) => void; } {\r\n        const delegate = new MultiDelegate<T>();\r\n        const invoke = (value: T) => delegate._callbacks.forEach((callback) => callback(value));\r\n\r\n        return { delegate: delegate, invoke: invoke };\r\n    }\r\n}\r\n\r\n","// only supported in Outlook 2019 and newer\r\nconst isCategoriesSupported = () => {\r\n\r\n    const isSupported = Office.context.requirements.isSetSupported(\"Mailbox\", \"1.8\");\r\n    console.info(\"Categories is supported: \", { isSupported });\r\n    return isSupported;\r\n}\r\nexport let isArchivedCategory: Office.CategoryDetails;\r\n\r\nexport async function tryInitializeCategories(): Promise<boolean> {\r\n\r\n    isArchivedCategory = isArchivedCategory ? isArchivedCategory : {\r\n        displayName: \"Archived with cks.DIGITAL 4.0\",\r\n        color: Office.MailboxEnums.CategoryColor.Preset7\r\n    };\r\n\r\n\r\n    const masterCategoriesToAdd: Office.CategoryDetails[] = [\r\n        isArchivedCategory,\r\n    ];\r\n\r\n    console.info(\"Initializing categories\");\r\n    if (!isCategoriesSupported) return false;\r\n\r\n\r\n    const existingCategories = await getMasterCategories();\r\n    const missingCategories = masterCategoriesToAdd\r\n        // only get categories that are not in existing categories\r\n        .filter(category => existingCategories.every(existing => existing.displayName !== category.displayName));\r\n    if (missingCategories.length === 0) return true;\r\n\r\n    const promise = new Promise<Office.AsyncResult<void>>(resolve => {\r\n        try {\r\n            Office.context.mailbox.masterCategories.addAsync(missingCategories, {}, resolve);\r\n        } catch (error) {\r\n            console.error(\"Error while adding master categories\", error);\r\n            throw error;\r\n        }\r\n    });\r\n\r\n    const result = await promise;\r\n\r\n    if (result.status === Office.AsyncResultStatus.Failed) {\r\n        console.error(\"Failed setting master categories\", result.error);\r\n        return false;\r\n    }\r\n\r\n    console.info(\"Successfully added categories to mater list\");\r\n\r\n    return true;\r\n}\r\n\r\n// export function tryInitializeCategoriesCallback(): void {\r\n// Office.context.mailbox.masterCategories.getAsync({},)\r\n// }\r\n\r\nfunction getMasterCategories(): Promise<Office.CategoryDetails[]> {\r\n    return new Promise<Office.CategoryDetails[]>((resolve, reject) => {\r\n        Office.context.mailbox.masterCategories.getAsync({}, result => {\r\n            if (result.status === Office.AsyncResultStatus.Failed) {\r\n                console.error(\"Failed getting master categories\", result.error);\r\n                reject(result.error);\r\n                return;\r\n            }\r\n\r\n            resolve(result.value);\r\n        })\r\n    })\r\n\r\n    // const promise = new Promise<Office.AsyncResult<Office.CategoryDetails[]>>(resolve => Office.context.mailbox.masterCategories.getAsync({}, resolve));\r\n\r\n    // const result = await promise;\r\n    // if (result.status === Office.AsyncResultStatus.Failed) {\r\n    //     console.error(\"Failed getting master categories\", result.error);\r\n    //     return null;\r\n    // }\r\n\r\n    // return result.value;\r\n}\r\n\r\n// tries to get the categories of the current item\r\nexport async function tryGetItemCategories(): Promise<Office.CategoryDetails[] | boolean> {\r\n    if (!isCategoriesSupported) return false;\r\n\r\n    const promise = new Promise<Office.AsyncResult<Office.CategoryDetails[]>>(resolve => Office.context.mailbox.item.categories.getAsync({}, resolve));\r\n\r\n    const result = await promise;\r\n\r\n    if (result.status === Office.AsyncResultStatus.Failed) {\r\n        console.error(\"Failed getting categories of current item\", result.error);\r\n        return false;\r\n    }\r\n\r\n    return result.value;\r\n}\r\n\r\n// tries to set an category to the current item\r\nexport async function tryAddCategoriesToItem(category: Office.CategoryDetails | string): Promise<boolean> {\r\n    if (!isCategoriesSupported()) return false;\r\n\r\n    const categoryName = typeof category === \"string\" ? category : category.displayName;\r\n    const promise = new Promise<Office.AsyncResult<void>>(resolve => Office.context.mailbox.item.categories.addAsync([categoryName], {}, resolve));\r\n    const result = await promise;\r\n\r\n    if (result.status === Office.AsyncResultStatus.Failed) {\r\n        console.error(\"Failed setting category\", { category }, result.error);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n","export const archiveDetails = \"archiveDetails\"\r\nexport default class customProperties {\r\n    private _properties: Office.CustomProperties;\r\n    private constructor(properties: Office.CustomProperties) {\r\n        this._properties = properties;\r\n    }\r\n\r\n    public static async load(): Promise<customProperties> {\r\n        const promise = new Promise<Office.AsyncResult<Office.CustomProperties>>(resolve => Office.context.mailbox.item.loadCustomPropertiesAsync(resolve));\r\n\r\n        const result = await promise;\r\n        if (result.status === Office.AsyncResultStatus.Failed) {\r\n            console.error(result.error);\r\n            return null;\r\n        }\r\n\r\n        return new customProperties(result.value);\r\n    }\r\n\r\n    public get<TValue>(name: string): TValue {\r\n        return this._properties.get(name) as TValue;\r\n    }\r\n\r\n    public update<TValue>(name: string, value: TValue): Promise<void> {\r\n        // documentation on method says value can be of any type but it is typed as string\r\n        // propably because it will be transfered as string\r\n        this._properties.set(name, value as any);\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            this._properties.saveAsync(result =>\r\n                result.status === Office.AsyncResultStatus.Failed\r\n                    ? reject(result.error)\r\n                    : resolve()\r\n            );\r\n        });\r\n    }\r\n}","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n","import { ITokens } from \"./ITokens\";\r\n\r\nconst dialogSessions = \"dialogSessions\";\r\nconst cksTokens = \"cks.tokens\";\r\n\r\nconst keys = { dialogOptions: dialogSessions, cksTokens, };\r\n\r\nexport default keys;\r\n\r\nexport function setTokens(tokens?: ITokens) {\r\n    set<ITokens>(cksTokens, tokens);\r\n}\r\n\r\nexport function getTokens(): ITokens {\r\n    return get<ITokens>(cksTokens);\r\n}\r\n\r\nfunction set<TValue>(key: string, value: TValue) {\r\n    if (typeof value === \"string\") {\r\n        localStorage.setItem(key, value);\r\n        return;\r\n    }\r\n\r\n    const json = JSON.stringify(value);\r\n    localStorage.setItem(key, json);\r\n}\r\n\r\n// do not use this to get strings\r\nfunction get<TValue>(key: string): TValue {\r\n    return JSON.parse(localStorage.getItem(key)) as TValue\r\n}","import * as Roaming from \"./RoamingSettings\";\r\nimport * as Logger from \"./Logger\";\r\nimport { using } from \"using-statement\";\r\nimport jwt_decode, { JwtPayload } from \"jwt-decode\";\r\nimport { MultiDelegate } from \"./MultiDelegate\";\r\nimport * as Storage from \"./LocalStorage\";\r\nimport { ITokens } from \"./ITokens\";\r\n\r\nexport class AuthenticationState {\r\n    private _tokens?: ITokens;\r\n\r\n    public getTokens() {\r\n        return this._tokens;\r\n    }\r\n\r\n    private _notifyStateChanged: () => void;\r\n\r\n    public authenticationStateChanged: MultiDelegate<void>;\r\n\r\n    private constructor() {\r\n        // by exposing the invoke on creation of \"delegate\" I avoid exposing the invoke to\r\n        // others that are not supposed to see or use it. This enables a better way to broadcast\r\n        // and avoid errors by not exposing the invoke\r\n        // the multi delegate also allows subscribing without the knwoledge of other subscribers\r\n        const { delegate, invoke } = MultiDelegate.create<void>();\r\n        this.authenticationStateChanged = delegate;\r\n        this._notifyStateChanged = () => {\r\n            console.info(\"authentication state changed. Current cached tokens:\", { tokens: this._tokens });\r\n            invoke();\r\n        };\r\n    }\r\n\r\n    // factory method because we are calling a function\r\n    // and are not just setting values\r\n    public static create(): AuthenticationState {\r\n        console.info(\"Creating authentications state\");\r\n        const state = new AuthenticationState();\r\n        const settings = Roaming.getSettings();\r\n\r\n\r\n        const tokens: ITokens = settings?.accessToken && settings.refreshToken ? {\r\n            access_token: settings.accessToken,\r\n            refresh_token: settings.refreshToken\r\n        } : null;\r\n\r\n        state._tokens = tokens ?? Storage.getTokens();\r\n        console.info(\"Created authentication state\", { state });\r\n        return state;\r\n    }\r\n\r\n    public async signIn(\r\n        user: string,\r\n        password: string,\r\n        api: string\r\n    ): Promise<boolean> {\r\n        console.info(\"signing in\");\r\n        const result = await this.fetchTokens(user, password, api);\r\n        if (!result) return false;\r\n\r\n        await this.setTokens(result);\r\n        this._notifyStateChanged();\r\n        return true;\r\n    }\r\n\r\n    private async fetchTokens(\r\n        user: string,\r\n        password: string,\r\n        api: string\r\n    ): Promise<ITokens | null> {\r\n        return await using(Logger.createScope(\"getting tokens\"), async () => {\r\n            const body = new URLSearchParams();\r\n\r\n            body.append(\"username\", user);\r\n            body.append(\"password\", password);\r\n\r\n            const url = new URL(\"/auth/login\", api);\r\n\r\n            console.log(\"URL: \" + url.toString());\r\n            let response: Response;\r\n            try {\r\n                response = await fetch(url.toString(), {\r\n                    method: \"POST\",\r\n                    body: body,\r\n                });\r\n            } catch (error) {\r\n                Logger.logError(\"Error while getting tokens\", error);\r\n                return null;\r\n            }\r\n\r\n            const tokens = await response.json();\r\n\r\n            return tokens as ITokens;\r\n        });\r\n    }\r\n\r\n    public async signOut(): Promise<void> {\r\n        console.info(\"Signing out\");\r\n        this.setTokens(null);\r\n        this._notifyStateChanged();\r\n    }\r\n\r\n    // used to set or delete tokens (setting to null)\r\n    private async setTokens(tokens?: ITokens): Promise<void> {\r\n        console.info(\"setting tokens:\", tokens);\r\n        // set memory\r\n        this._tokens = tokens;\r\n        // set localStorage\r\n        Storage.setTokens(tokens);\r\n        console.info(\"Loading old roaming settings to replace only tokens\");\r\n        const old = Roaming.getSettings();\r\n        console.info(\"Loaded old roaming settings\");\r\n        // set roaming settings\r\n        console.info(\"Setting tokens to roaming settings\", { accessToken: tokens?.access_token, refreshing: tokens?.refresh_token });\r\n        await Roaming.setSettings({ api: old?.api, accessToken: tokens?.access_token, refreshToken: tokens?.refresh_token });\r\n    }\r\n\r\n    // tries refreshing access token (and refresh token) with the refresh token\r\n    // returns false if there is no refresh token saved or no api address saved or\r\n    private async refreshTokens(): Promise<boolean> {\r\n        return await using(Logger.createScope(\"refreshing token\"), async () => {\r\n            if (!this._tokens?.refresh_token || !this._tokens.access_token) {\r\n                const { accessToken, refreshToken } = Roaming.getSettings();\r\n                if (!accessToken || !refreshToken || !(this._tokens = Storage.getTokens())) {\r\n\r\n\r\n                    Logger.logError(\"Cannot refresh if tokens are null\");\r\n                    return false;\r\n                } else {\r\n                    this._tokens = { access_token: accessToken, refresh_token: refreshToken };\r\n                }\r\n            }\r\n\r\n            const api = Roaming.getSettings()?.api;\r\n            if (api == null) return false;\r\n\r\n            const url = new URL(\"/auth/refresh\", api);\r\n\r\n            let response: Response;\r\n            try {\r\n                response = await fetch(url.toString(), {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                    },\r\n                    body: JSON.stringify({\r\n                        access_token: this._tokens.access_token,\r\n                        refresh_token: this._tokens.refresh_token\r\n                    }),\r\n                });\r\n            } catch (error) {\r\n                Logger.logError(error);\r\n                return false;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                Logger.logError(\"Response for refreshing tokens does not indicate success. Therefore refresh token is invalid. Signing out\", { response });\r\n                await this.signOut();\r\n                return false;\r\n            }\r\n\r\n            const tokens = (await response.json()) as ITokens;\r\n            this.setTokens(tokens);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    private isExpired(accessToken: string): boolean {\r\n        console.info(\"Checking if access token is expired\");\r\n        const decoded = jwt_decode<JwtPayload>(accessToken);\r\n        const currentTime = new Date().getTime() / 1000;\r\n        const tokenExpires = decoded.exp;\r\n        console.info(\r\n            `Access token exp is ${tokenExpires} and current time is ${currentTime}`\r\n        );\r\n        if (tokenExpires < currentTime) {\r\n            console.info(\"Access token expired\");\r\n            return true;\r\n        }\r\n\r\n        console.info(\"Access token is not expired\");\r\n        return false;\r\n        // could also compare issuer against api address / configured issuer\r\n        // or validate signature if the signature is asynchonous (as in signed with a public/private key pair)\r\n    }\r\n\r\n    public async isAuthenticated(): Promise<boolean> {\r\n        console.info(\"Checking if authenticated\");\r\n        const isTokensValid = () => this._tokens?.access_token && this._tokens.refresh_token;\r\n        // 1. check memory\r\n        if (!isTokensValid()) {\r\n            console.info(\r\n                \"No tokens cached. Trying to load from roaming settings\"\r\n            );\r\n            // 2. try to assign from roaming settings\r\n            const settings = Roaming.getSettings();\r\n            this._tokens = settings?.accessToken && settings.refreshToken\r\n                ? { access_token: settings.accessToken, refresh_token: settings.refreshToken }\r\n                // 3. try to assign from local storage\r\n                : Storage.getTokens();\r\n\r\n            // if there are still no tokens then user is simply not authenticated\r\n            if (!isTokensValid()) {\r\n                console.info(\r\n                    \"No tokens in roaming settings or local storage. User is not authenticated\"\r\n                );\r\n                return false;\r\n            }\r\n        }\r\n\r\n        console.info(\"Tokens found and loaded!\", this._tokens);\r\n\r\n        // if tokens are set. check if expired\r\n        if (!this.isExpired(this._tokens.access_token)) return true;\r\n\r\n        return await this.refreshTokens();\r\n    }\r\n}\r\n","import { IDisposable } from \"@fluentui/react\";\r\n\r\nexport function logError(message: any, ...optionalParams: any[]) {\r\n  console.error(message, ...optionalParams);\r\n}\r\n// export function logError(...data: any[]) {\r\n//   console.error(...data);\r\n// }\r\n\r\nexport const createScope = (name?: string) => new ScopedLogger(name);\r\n\r\nexport class ScopedLogger implements IDisposable {\r\n  constructor(name?: string) {\r\n    console.group(name);\r\n  }\r\n\r\n  dispose() {\r\n    console.groupEnd();\r\n  }\r\n}\r\n","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./using\"));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction using(resource, func) {\r\n    let shouldDispose = true;\r\n    let result = undefined;\r\n    try {\r\n        result = func(resource);\r\n        // dispose it asynchronously if it returns a promise\r\n        if (isPromise(result)) {\r\n            const capturedResult = result;\r\n            shouldDispose = false;\r\n            return result.finally(() => dispose(resource)).then(() => capturedResult);\r\n        }\r\n        else if (isIterator(result)) {\r\n            shouldDispose = false;\r\n            const originalNext = result.next;\r\n            result.next = function () {\r\n                let shouldDispose = false;\r\n                try {\r\n                    const args = Array.from(arguments);\r\n                    const iterationResult = originalNext.apply(this, args);\r\n                    if (iterationResult.done)\r\n                        shouldDispose = true;\r\n                    return iterationResult;\r\n                }\r\n                catch (err) {\r\n                    shouldDispose = true;\r\n                    throw err;\r\n                }\r\n                finally {\r\n                    if (shouldDispose)\r\n                        dispose(resource);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    finally {\r\n        if (shouldDispose) {\r\n            const disposeResult = dispose(resource);\r\n            if (isPromise(disposeResult)) {\r\n                let finalPromise = result == null ? undefined : Promise.resolve(result);\r\n                if (finalPromise == null)\r\n                    result = disposeResult;\r\n                else\r\n                    result = disposeResult.then(() => finalPromise);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.using = using;\r\nconst funcNames = [\"dispose\", \"close\", \"unsubscribe\"];\r\nfunction dispose(obj) {\r\n    if (obj == null)\r\n        return;\r\n    for (const funcName of funcNames) {\r\n        if (typeof obj[funcName] === \"function\") {\r\n            return obj[funcName]();\r\n        }\r\n    }\r\n    throw new Error(\"Object provided to using did not have a dispose method.\");\r\n}\r\nfunction isPromise(obj) {\r\n    return obj != null\r\n        && typeof obj.then === \"function\"\r\n        && typeof obj.finally === \"function\";\r\n}\r\nfunction isIterator(obj) {\r\n    return obj != null\r\n        && typeof obj.next === \"function\";\r\n}\r\n","function e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";export default o;export{n as InvalidTokenError};\n//# sourceMappingURL=jwt-decode.esm.js.map\n","import { AuthenticationState } from \"./AuthenticationState\";\r\nimport ICodeName from \"./models/ICodeName\";\r\nimport ICreateEmailArchiveRequest from \"./models/ICreateEmailArchiveRequest\";\r\nimport IDocumentResponse from \"./models/IDocumentResponse\";\r\nimport IIdName from \"./models/IIdName\";\r\nimport ISession from \"./models/ISession\";\r\nimport { MultiDelegate } from \"./MultiDelegate\";\r\nimport { getSettings } from \"./RoamingSettings\";\r\n\r\nexport class ApiClient {\r\n\r\n    private readonly invokeRequestFailed: (statusCode: number) => void;\r\n    private readonly authState: AuthenticationState;\r\n\r\n    public readonly onRequestFailed: MultiDelegate<number>;\r\n\r\n    public constructor(authState: AuthenticationState) {\r\n        this.authState = authState;\r\n        const { delegate, invoke } = MultiDelegate.create<number>();\r\n        this.invokeRequestFailed = invoke;\r\n        this.onRequestFailed = delegate;\r\n    }\r\n\r\n    public getCategories(database: string): Promise<Array<IIdName>> {\r\n        console.info(\"getting categories\");\r\n\r\n        console.info(\"getting object types\");\r\n\r\n        const query = \"database=\" + database;\r\n        const url = \"/categories?\" + query;\r\n        return this.get<Array<IIdName>>(url);\r\n    }\r\n\r\n    public getObjectTypes(database: string): Promise<Array<IIdName>> {\r\n        console.info(\"getting object types\");\r\n\r\n        const query = \"database=\" + database;\r\n        const url = \"/objecttypes?\" + query;\r\n        return this.get<Array<IIdName>>(url);\r\n    }\r\n\r\n    public getActiveSessions(): Promise<Array<ISession>> {\r\n        console.info(\"getting active sessions\");\r\n\r\n        return this.get<Array<ISession>>(\"/users/current/sessions\");\r\n    }\r\n\r\n    public getBusinessPartnersByMail(database: string, address: string): Promise<Array<ICodeName>> {\r\n        console.info(\"getting business partners by mail\");\r\n\r\n        const query = `database=${database}`;\r\n        const url = `/businesspartners/${address}?` + query;\r\n\r\n        return this.get<Array<ICodeName>>(url);\r\n    }\r\n\r\n    public getBusinessPartners(database: string, type?: number): Promise<Array<ICodeName>> {\r\n        console.info(\"getting business partners\");\r\n\r\n        const query = `database=${database}&type=${type}`;\r\n        const url = \"/businesspartners?\" + query;\r\n\r\n        return this.get<Array<ICodeName>>(url);\r\n    }\r\n\r\n    // code is the card code of the business partner\r\n    public getDocumentsOfBusinessPartner(database: string, code: string, type?: number): Promise<Array<IDocumentResponse>> {\r\n        console.info(\"getting documents for business partner\");\r\n\r\n        const query = `database=${database}`;\r\n        const url = `/businesspartners/${code}/documents/${type}?` + query;\r\n\r\n        return this.get<Array<IDocumentResponse>>(url);\r\n    }\r\n\r\n    public updateExchangeToken(exchangeToken: string): Promise<void> {\r\n        console.info(\"Updating exchange token\");\r\n\r\n        const url = \"/users/current/exchangeToken\";\r\n\r\n        return this.update(url, { exchangeToken: exchangeToken });\r\n    }\r\n\r\n    public async createEmailArchive(request: ICreateEmailArchiveRequest): Promise<number> {\r\n\r\n        console.info(\"Creating archive for email\");\r\n        const url = \"/archives/emails\";\r\n        const result = await this.create(url, request) as { id: number };\r\n        return result?.id;\r\n    }\r\n\r\n    public async getDocumentOfArchive(archiveId: number, database: string) : Promise<IDocumentResponse> {\r\n        console.info(\"Getting document of archive\", { archiveId });\r\n        const url = `/archives/${archiveId}/document?database=${database}`;\r\n        const result = await this.get(url) as IDocumentResponse;\r\n        return result;\r\n    }\r\n\r\n    private async get<T>(relativeUrl: string): Promise<T> {\r\n\r\n        const { access_token } = this.authState.getTokens();\r\n        let { api, accessToken } = getRequirements();\r\n        accessToken ??= access_token;\r\n        if (!api || !accessToken) {\r\n            console.error(\r\n                \"api address or access token is not provided can't execute get for \", relativeUrl);\r\n            return null;\r\n        }\r\n\r\n        const url = new URL(relativeUrl, api);\r\n        let response: Response;\r\n        try {\r\n            response = await fetch(url.toString(), {\r\n                method: \"GET\",\r\n                headers: {\r\n                    Authorization: \"Bearer \" + accessToken,\r\n                },\r\n            });\r\n\r\n            if (!response.ok) {\r\n                this.invokeRequestFailed(response.status);\r\n            }\r\n\r\n            return (await response.json()) as T;\r\n        } catch (error) {\r\n            console.error(error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private async update<TValue>(relativeUrl: string, value: TValue): Promise<void> {\r\n\r\n        const { access_token } = this.authState.getTokens();\r\n        let { api, accessToken } = getRequirements();\r\n        accessToken ??= access_token;\r\n        if (!api || !accessToken) {\r\n            console.error(\r\n                \"api address or access token is not provided can't execute update for \", relativeUrl);\r\n            return null;\r\n        }\r\n\r\n        const url = new URL(relativeUrl, api);\r\n        let response: Response;\r\n        try {\r\n            response = await fetch(url.toString(), {\r\n                method: \"PUT\",\r\n                headers: {\r\n                    Authorization: \"Bearer \" + accessToken,\r\n                    \"Content-Type\": \"application/json\",\r\n                },\r\n                body: JSON.stringify(value)\r\n            });\r\n\r\n            if (!response.ok) {\r\n                this.invokeRequestFailed(response.status);\r\n            }\r\n\r\n            return;\r\n        } catch (error) {\r\n            console.error(error);\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n    private async create<TResult, TValue>(relativeUrl: string, value: TValue): Promise<TResult> {\r\n\r\n        const { access_token } = this.authState.getTokens();\r\n        let { api, accessToken } = getRequirements();\r\n        accessToken ??= access_token;\r\n        if (!api || !accessToken) {\r\n            console.error(\r\n                \"api address or access token is not provided can't execute create for \", relativeUrl);\r\n            return null;\r\n        }\r\n\r\n        const url = new URL(relativeUrl, api);\r\n        let response: Response;\r\n        try {\r\n            response = await fetch(url.toString(), {\r\n                method: \"POST\",\r\n                headers: {\r\n                    Authorization: \"Bearer \" + accessToken,\r\n                    \"Content-Type\": \"application/json\",\r\n                },\r\n                body: JSON.stringify(value)\r\n            });\r\n\r\n            if (!response.ok) {\r\n                this.invokeRequestFailed(response.status);\r\n            }\r\n\r\n            // not needed to be awaited if TResult is void but idk how to change that\r\n            return await response.json() as TResult;\r\n        } catch (error) {\r\n            console.error(error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// gets requirements for api access\r\nfunction getRequirements(): { api: string; accessToken: string } {\r\n    console.info(\"Getting required settings\");\r\n    const settings = getSettings();\r\n    console.info(\"Loaded settings\", settings);\r\n    return { api: settings?.api, accessToken: settings?.accessToken,};\r\n}\r\n","export function add(key: string, JSONmessage: Office.NotificationMessageDetails) {\r\n    return new Promise<void>((resolve, reject) => {\r\n        Office.context.mailbox.item.notificationMessages.addAsync(key, JSONmessage, {}, result => {\r\n            if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            console.error(\"Failed adding notification\", result.error);\r\n            reject(result.error);\r\n        });\r\n    })\r\n}\r\nexport function replace(key: string, JSONmessage: Office.NotificationMessageDetails) {\r\n    console.info(\"Replacing notification message\", { key, JSONmessage });\r\n    return new Promise<void>((resolve, reject) => {\r\n        Office.context.mailbox.item.notificationMessages.replaceAsync(key, JSONmessage, {}, result => {\r\n            if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            console.error(\"Failed adding notification\", result.error);\r\n            reject(result.error);\r\n        });\r\n    })\r\n}\r\n\r\nexport function remove(key: string): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n        Office.context.mailbox.item.notificationMessages.removeAsync(key, {}, result => {\r\n            if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            console.error(\"Failed removing notification\", { key, error: result.error });\r\n            reject(result.error);\r\n        })\r\n    });\r\n}\r\n\r\nexport const actionKey = \"action\";\r\n\r\nconst Notifications = { add, replace, remove };\r\nexport default Notifications;\r\n","import Mailbox from \"./Mailbox\";\r\nimport { IEmailIdentifier } from \"./models/ICreateEmailArchiveRequest\";\r\n\r\n\r\nexport function getItemId(): string {\r\n\r\n    const hostName = Office.context.mailbox.diagnostics.hostName;\r\n    const itemId = Office.context.mailbox.item.itemId;\r\n    // if is mobile\r\n    if (hostName === \"OutlookIOS\" || hostName === \"OutlookAndroid\") {\r\n        // itemId is already REST-formatted.\r\n        return itemId;\r\n    }\r\n\r\n    // Convert to an item ID for API v2.0.\r\n    // there is also a method available for converting to ews id\r\n    return Office.context.mailbox.convertToRestId(itemId, Office.MailboxEnums.RestVersion.v2_0);\r\n}\r\nexport async function getEmailIdentifier(): Promise<IEmailIdentifier> {\r\n    const tokenPromise = Mailbox.getCallBackToken();\r\n\r\n    const itemId = getItemId();\r\n    const restUrl = Office.context.mailbox.restUrl;\r\n    const token = await tokenPromise;\r\n    const sender = Office.context.mailbox.item?.sender.emailAddress.toLowerCase();\r\n    const user = Office.context.mailbox.userProfile.emailAddress.toLowerCase();\r\n\r\n    return { accessToken: token, restUrl: restUrl, itemId: itemId, isSent: sender === user };\r\n}\r\n\r\nconst Item = { getItemId, getEmailIdentifier };\r\nexport default Item;\r\n","\r\n/*\r\n  TODO does require API Requirment Set 1.5 which is only available in 2019 going forward\r\n  need to implement getting mail via exchange \r\n  and combine information from \r\n  https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-export-items-by-using-ews-in-exchange\r\n  with \r\n  https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/web-services\r\n  and maybe\r\n  https://docs.microsoft.com/en-us/office/dev/add-ins/outlook/get-attachments-of-an-outlook-item\r\n  */\r\nexport function getCallBackToken(): Promise<string> {\r\n    return new Promise<string>((resolve, reject) => {\r\n\r\n        Office.context.mailbox.getCallbackTokenAsync({}, result => {\r\n            if (result.status === Office.AsyncResultStatus.Failed) {\r\n                reject(result.error);\r\n                console.error(\"Failed getting callback token\", { result });\r\n                return;\r\n            }\r\n\r\n            console.info(\"Succeeded getting callback token\", { result });\r\n            resolve(result.value);\r\n        })\r\n    })\r\n}\r\n\r\nconst Mailbox = { getCallBackToken };\r\nexport default Mailbox;","/* global global, Office, self, window */\n\n// import { AuthenticationState } from \"../AuthenticationState\";\n// import { ApiClient } from \"../CksApiClient\";\nimport { AuthenticationState } from \"../AuthenticationState\";\nimport { isArchivedCategory, tryAddCategoriesToItem, tryInitializeCategories } from \"../Categories\";\nimport { ApiClient } from \"../CksApiClient\";\nimport customProperties, { archiveDetails } from \"../CustomProperties\";\nimport { displayDialog } from \"../Dialog\";\nimport { IOption } from \"../dialog/components/ChooseFromDialog\";\nimport Item from \"../Item\";\nimport keys from \"../LocalStorage\";\nimport { IArchiveProperty, IDatabaseArchive } from \"../models/IArchiveProperty\";\nimport ICodeName from \"../models/ICodeName\";\nimport ICreateEmailArchiveRequest, { IArchiveIdentifier } from \"../models/ICreateEmailArchiveRequest\";\nimport ISession from \"../models/ISession\";\nimport Notifications, { actionKey } from \"../NotificationMessages\";\n\nlet resolveOnReady: () => void;\nconst onReady = new Promise<void>(resolve => {\n  resolveOnReady = resolve;\n})\n\nOffice.onReady(() => {\n  // If needed, Office.js is ready to be called\n  console.info(\"Office is ready\");\n  resolveOnReady();\n});\n\nasync function initializeAction(): Promise<{ isInitialized: boolean, api?: ApiClient }> {\n\n  console.info(\"Awaiting on ready\");\n\n  await onReady;\n\n  const state = AuthenticationState.create();\n\n  console.info(\"Checking if authenticated\");\n\n  if (!await state.isAuthenticated()) {\n    const signInMessage: Office.NotificationMessageDetails = {\n      type: Office.MailboxEnums.ItemNotificationMessageType.ErrorMessage,\n      message: \"Please open \\\"Archive behind document\\\" to sign in\",\n    };\n\n    await Notifications.replace(actionKey, signInMessage);\n\n    return { isInitialized: false };\n  }\n\n  return { isInitialized: true, api: new ApiClient(state) }\n}\n/**\n * tries to create an archive and show notifications if it failed or succeeded\n * also sets the custom properties using the properties object provided\n *\n * @param request the request to send used to create an archive\n * @param api the api client used to send the archive request\n * @param properties the properties object to add the archived custom properties to the mail\n * @param archivedInDatabases the databases the mail was already archived in\n * @param createSuccessMessage a function to resolve the success message in case the archiving was successful\n * @returns a boolean indicating if the archiving was successful\n */\nasync function tryCreateArchive(request: ICreateEmailArchiveRequest, api: ApiClient, properties: customProperties, archivedInDatabases: IDatabaseArchive[], createSuccessMessage: (archiveId: number, request: ICreateEmailArchiveRequest) => string): Promise<boolean> {\n\n  const archiveId = await api.createEmailArchive(request);\n  if (!archiveId) {\n    console.error(\"Creating archive did not return the new id which indicates the creation of the archive was not successful\");\n    const errorMessage: Office.NotificationMessageDetails = {\n      type: Office.MailboxEnums.ItemNotificationMessageType.ErrorMessage,\n      message: \"Sorry, could not create an archive for this mail\",\n    };\n\n    await Notifications.replace(actionKey, errorMessage);\n    return false;\n  }\n\n\n  // update archived in databases for mail\n  archivedInDatabases.push({ database: request.archive.database, archiveId });\n  const propertiesPromise = properties.update<IArchiveProperty>(archiveDetails, {\n    archivedInDatabases: archivedInDatabases\n  });\n\n\n  // try set category if supported by this outlook client\n  const categoriesPromise = tryInitializeCategories()\n    .then(isInitialized => {\n      if (isInitialized)\n        tryAddCategoriesToItem(isArchivedCategory);\n    });\n\n  await Promise.all([propertiesPromise, categoriesPromise]);\n\n  const successMessage: Office.NotificationMessageDetails = {\n    type: Office.MailboxEnums.ItemNotificationMessageType.InformationalMessage,\n    message: createSuccessMessage(archiveId, request),\n    icon: \"Icon.80x80\",\n    persistent: true,\n  };\n\n  await Notifications.replace(actionKey, successMessage);\n\n  return true;\n}\n\nasync function showChooseOptionDialog(options: IOption[]): Promise<string> {\n\n  // transmit companies where not archived yet to dialog\n  const messageToChild = JSON.stringify(options);\n\n  // cannot use messageChild api since that is requirement set Mailbox 1.9 \n  // and I need to wait until office is ready in dialog until I can send messages to dialog\n  // that would require initiating dialog > waiting till office is initalized in dialog > dialog registers event to listen to messages from paren > dialog messages parent that its listening > parent sends data to child > ... 😟\n  // check for requirement set and use messageChild\n\n\n  // use local storage instead\n  localStorage.setItem(keys.dialogOptions, messageToChild);\n  /*  localstorage seems to not work from one day to another on windows outlook (365) client.\n      After opening the dialog the localStorage is empty.\n      even though it seems to be the same origin. Need to investigate again later.\n      But until then send databases in query (I would really prefer not to send the databases through the network)\n  */\n\n  // sessions to query (I would really prefer not to)\n\n  const query = new URLSearchParams(options.map(({ key, value }) => [key, value]))\n  const location = window.location.origin + \"/dialog.html?\" + query.toString();\n  console.info(\"Opening dialog at \", location);\n  // awaits only the opening not the closing\n  const dialog = await displayDialog(location, { height: 30, width: 20, displayInIframe: true })\n  console.info({ dialog });\n\n  // create promise that is resolved when the dialog closes or a database is chosen\n  const databaseSelectedPromise = new Promise<{ message: string | boolean } | { error: number }>(resolve => {\n    dialog.addEventHandler(Office.EventType.DialogEventReceived, resolve);\n    dialog.addEventHandler(Office.EventType.DialogMessageReceived, resolve);\n  });\n\n\n  console.info(\"Awaiting database to be selected\");\n  const argument = await databaseSelectedPromise;\n\n  console.info(\"Awaiting completed\");\n  const key = \"message\" in argument ? argument.message.toString() : null;\n\n\n  if (\"error\" in argument)\n    switch (argument.error) {\n      case 12002:\n        let message = \"The dialog box has been directed to a page that it cannot find or load, or the URL syntax is invalid.\";\n        console.error(message);\n        break;\n      case 12003:\n        message = \"The dialog box has been directed to a URL with the HTTP protocol. HTTPS is required.\";\n        console.error(message);\n        break;\n      case 12006:\n        console.info(\"Dialog closed.\");\n        break;\n      default:\n        message = \"Unknown error in dialog box.\";\n        console.error(message);\n        break;\n    }\n\n  console.info(\"Dialog was closed with\", { key });\n\n  // don't call close if it was closed by user (then key is null)\n  if (key)\n    dialog.close();\n\n  // clean up because no longer needed\n  localStorage.removeItem(keys.dialogOptions);\n  return key;\n}\n\n/**\n * Runs an archive action for the current mail that can be modified the function parameters\n */\nasync function runArchiveAction<TSessionContext extends { session: ISession }>\n  (\n    event: Office.AddinCommands.Event,\n    getValidSessions: (api: ApiClient, sessions: ISession[]) => Promise<TSessionContext[]>,\n    getArchiveIdentifier: (chosenContext: TSessionContext) => Promise<IArchiveIdentifier>,\n    generateSuccessMessage: (params: ISuccessMessageParams) => string\n  ) {\n  try {\n    const { isInitialized, api } = await initializeAction();\n\n    if (!isInitialized) {\n      event.completed();\n      return;\n    }\n\n    let sessions = await api.getActiveSessions();\n    if (!sessions || sessions.length === 0) {\n      console.error(\"No sessions to archive\", { sessions });\n      const noSessionMessage: Office.NotificationMessageDetails = {\n        type: Office.MailboxEnums.ItemNotificationMessageType.ErrorMessage,\n        message: \"Sorry, could not get databases to archive behind. Please check if you can sign in.\"\n      }\n\n      await Notifications.replace(actionKey, noSessionMessage);\n      event.completed();\n      return;\n    }\n\n\n    // get companies that are already archived behind\n    const properties = await customProperties.load();\n    const archivedInDatabases = properties.get<IArchiveProperty>(archiveDetails)?.archivedInDatabases ?? [];\n\n    if (archivedInDatabases.length === 0)\n      sessions = sessions\n        // not in these databases where already archived\n        .filter(session => archivedInDatabases.every(({ database }) => session.database !== database));\n\n    // if no company is left show message no company + \"you can add more in settings\"\n\n    const noSessionMessage: Office.NotificationMessageDetails = {\n      type: Office.MailboxEnums.ItemNotificationMessageType.InformationalMessage,\n      icon: \"Icon.80x80\",\n      message: \"No company found. You can add more companies under \\\"Archive behind document\\\"\",\n      persistent: true,\n    };\n\n    if (sessions.length === 0) {\n      await Notifications.replace(actionKey, noSessionMessage);\n      event.completed();\n      return;\n    }\n\n    // get valid sessions if function is provided otherwise all sessions are valid\n    const valid = await getValidSessions(api, sessions);\n    // if null then it was handled by getValidSessions function\n    if (!valid) {\n      event.completed();\n      return;\n    }\n    if (valid.length === 0) {\n      console.error(\"No valid session. Need at least one valid session\");\n\n      await Notifications.replace(actionKey, noSessionMessage);\n      event.completed();\n      return;\n    }\n\n    let options: IOption[] = valid.map(result => ({ key: result.session.database, value: result.session.companyName }));\n    const database = await showChooseOptionDialog(options);\n    // if null dialog was closed by user which is the same as cancelling for us\n    if (!database) {\n      console.info(\"Dialog closed by user without selecting a database\");\n      // don't need to remove action manually since outlook already removes it when calling event.completed()\n      // await Notifications.remove(actionKey);\n      event.completed();\n      return;\n    }\n\n    console.info(\"User selected database\", { database });\n    const selectedCompany = sessions.find(session => session.database === database).companyName;\n    const message: Office.NotificationMessageDetails = {\n      type: Office.MailboxEnums.ItemNotificationMessageType.ProgressIndicator,\n      message: `Archiving email in company ${selectedCompany}.`,\n    };\n\n    Notifications.replace(actionKey, message);\n\n    // get chosen context\n    const chosenContext = valid.find(({ session }) => session.database === database);\n\n    const email = await Item.getEmailIdentifier();\n    // the as is cheating but if no method to generate session contexts is supplied then no other properties on session context should be expected\n    const archive = await getArchiveIdentifier(chosenContext);\n    if (!archive) {\n      event.completed();\n      return;\n    }\n\n    await tryCreateArchive({ archive, email }, api, properties, archivedInDatabases, (archiveId, request) => generateSuccessMessage({ archiveId, request, session: chosenContext.session }));\n    event.completed();\n  } catch (error) {\n    console.error(error);\n    const exceptionMessage: Office.NotificationMessageDetails = {\n      type: Office.MailboxEnums.ItemNotificationMessageType.ErrorMessage,\n      // message: \"Sorry, something went wrong\"\n      message: JSON.stringify(error)\n    }\n\n    await Notifications.replace(actionKey, exceptionMessage);\n  }\n\n}\n\nasync function archiveBehindBusinessPartner(event: Office.AddinCommands.Event) {\n\n  const getValidSessions = async (api: ApiClient, sessions: ISession[]) => {\n    const address = Office.context.mailbox.item.sender.emailAddress;\n    console.info(\"Getting business partners that match address from sessions\", { address, sessions });\n    const getAddressesPromisses = sessions.map(async (session) => {\n      const partners = await api.getBusinessPartnersByMail(session.database, address)\n      return { session, partners };\n    });\n\n    const results = await Promise.all(getAddressesPromisses);\n    console.info(\"Got the following results\", { results });\n\n    // only use companies that have a business partner\n    const valid = results.filter(result => result?.partners && result.partners.length !== 0);\n    if (valid.length === 0) {\n      console.info(\"Got no business partner with matching email address\");\n\n      const notFoundMessage: Office.NotificationMessageDetails = {\n        type: Office.MailboxEnums.ItemNotificationMessageType.ErrorMessage,\n        message: `No business partner with address ${address} found`\n      }\n\n      await Notifications.replace(actionKey, notFoundMessage);\n      return null;\n    }\n\n    return valid;\n  }\n\n  const getArchiveIdentifier = async (chosenContext: { session: ISession, partners: ICodeName[] }): Promise<IArchiveIdentifier> => {\n    const options = chosenContext.partners.map(({ code, name }) => ({ key: code, value: `${code} - ${name}` }));\n    const code = await showChooseOptionDialog(options);\n\n    // handle not selected / closed by user\n    if (!code) {\n      console.info(\"Dialog closed by user without selecting a business partner\");\n      return null;\n    }\n\n    return {\n      database: chosenContext.session.database,\n      key1: code,\n      // business partners (should swap with enum at some point)\n      type: 2,\n      businessPartnerCode: code\n    }\n  }\n  // const generateSuccessMessage = (archiveId: number, request: ICreateEmailArchiveRequest, context: { session: ISession }) => `Successfully archived mail for ${context.session.companyName} with archiveId ${archiveId}`;\n  const generateSuccessMessage: (params: ISuccessMessageParams) => string = ({ archiveId, request, session }) => `Successfully archived mail for ${session.companyName} with archiveId ${archiveId} behind business partner ${request.archive.key1}`;\n\n\n  await runArchiveAction(event, getValidSessions, getArchiveIdentifier, generateSuccessMessage);\n}\n\nasync function archiveInInbox(event: Office.AddinCommands.Event) {\n  // just return the sessions\n  const getValidSessions = (_: ApiClient, sessions: ISession[]) => Promise.resolve(sessions.map(session => ({ session })));\n  const getArchiveIdentifier = async (chosenContext: { session: ISession }): Promise<IArchiveIdentifier> => ({\n    database: chosenContext.session.database,\n    // inbox\n    type: 0,\n    key1: \"\",\n  });\n\n  const generateSuccessMessage: (params: ISuccessMessageParams) => string = ({ archiveId, session }) => `Successfully archived mail for ${session.companyName} with archiveId ${archiveId} in inbox`;\n\n  await runArchiveAction(event, getValidSessions, getArchiveIdentifier, generateSuccessMessage);\n}\n\ninterface ISuccessMessageParams {\n  archiveId: number;\n  request: ICreateEmailArchiveRequest;\n  session: ISession;\n}\n\n\nfunction getGlobal() {\n  return typeof self !== \"undefined\"\n    ? self\n    : typeof window !== \"undefined\"\n      ? window\n      : typeof global !== \"undefined\"\n        ? global\n        : undefined;\n}\n\nconst g = getGlobal() as any;\n\n// the add-in command functions need to be available in global scope\ng.archiveInInbox = archiveInInbox;\ng.archiveBehindBusinessPartner = archiveBehindBusinessPartner;\n","export function displayDialog(startAddress: string, options? : Office.DialogOptions) : Promise<Office.Dialog>{\r\n    return new Promise<Office.Dialog>((resolve, reject) => {\r\n        Office.context.ui.displayDialogAsync(startAddress, options, result => {\r\n            if (result.status === Office.AsyncResultStatus.Succeeded) {\r\n                resolve(result.value);\r\n                return;\r\n            }\r\n\r\n            console.error(\"Error while openen dialog\", result.error);\r\n            reject(result.error);\r\n        });\r\n    })\r\n}","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}